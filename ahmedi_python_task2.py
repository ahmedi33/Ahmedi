# -*- coding: utf-8 -*-
"""Ahmedi_python_task2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YVlE2UYsNfdw1oWy50_96bdnqBEiBmzt
"""

import pandas as pd

def calculate_distance_matrix(df)->pd.DataFrame():
    """
    Calculate a distance matrix based on the dataframe, df.

    Args:
        df (pandas.DataFrame)

    Returns:
        pandas.DataFrame: Distance matrix
    """
    # Write your logic here
     # Assuming 'latitude' and 'longitude' are the column names in your DataFrame
    coordinates = df[['latitude', 'longitude']].values

    # Calculate the distance matrix using the Euclidean distance
    distance_matrix = pd.DataFrame(cdist(coordinates, coordinates, metric='euclidean'))

    # Optionally, you can set the index and column names based on your data
    distance_matrix.index = df.index
    distance_matrix.columns = df.index

    return distance_matrix

# Example usage:
# distance_matrix = calculate_distance_matrix(your_dataframe)

    return df

def unroll_distance_matrix(df)->pd.DataFrame():
    """
    Unroll a distance matrix to a DataFrame in the style of the initial dataset.

    Args:
        df (pandas.DataFrame)

    Returns:
        pandas.DataFrame: Unrolled DataFrame containing columns 'id_start', 'id_end', and 'distance'.
    """
    # Write your logic here
    # Get the indices of the distance matrix
    indices = df.index

    # Initialize empty lists to store unrolled data
    id_start_list = []
    id_end_list = []
    distance_list = []

    # Iterate over indices to fill the lists
    for id_start in indices:
        for id_end in indices:
            # Skip diagonal elements (distance from a location to itself)
            if id_start != id_end:
                id_start_list.append(id_start)
                id_end_list.append(id_end)
                distance_list.append(df.loc[id_start, id_end])

    # Create the unrolled DataFrame
    unrolled_df = pd.DataFrame({
        'id_start': id_start_list,
        'id_end': id_end_list,
        'distance': distance_list
    })

    return unrolled_df

# Example usage:
# unrolled_dataframe = unroll_distance_matrix(your_distance_matrix)

    return df

def find_ids_within_ten_percentage_threshold(df, reference_id)->pd.DataFrame():
    """
    Find all IDs whose average distance lies within 10% of the average distance of the reference ID.

    Args:
        df (pandas.DataFrame)
        reference_id (int)

    Returns:
        pandas.DataFrame: DataFrame with IDs whose average distance is within the specified percentage threshold
                          of the reference ID's average distance.
    """
    # Write your logic here
    # Filter the DataFrame to include only rows related to the reference_id
    reference_data = df[(df['id_start'] == reference_id) | (df['id_end'] == reference_id)]

    # Calculate the average distance of the reference_id
    reference_avg_distance = reference_data['distance'].mean()

    # Calculate the threshold values
    lower_threshold = reference_avg_distance - (0.1 * reference_avg_distance)
    upper_threshold = reference_avg_distance + (0.1 * reference_avg_distance)

    # Filter the DataFrame based on the threshold values
    filtered_df = df[
        (df['id_start'] != df['id_end']) &  # Avoid self-pairing
        ((df['id_start'] == reference_id) | (df['id_end'] == reference_id)) &  # Related to reference_id
        (lower_threshold <= df['distance']) & (df['distance'] <= upper_threshold)  # Within the threshold
    ]

    return filtered_df

# Example usage:
# result_dataframe = find_ids_within_ten_percentage_threshold(your_dataframe, your_reference_id)

    return df

def calculate_toll_rate(df)->pd.DataFrame():
    """
    Calculate toll rates for each vehicle type based on the unrolled DataFrame.

    Args:
        df (pandas.DataFrame)

    Returns:
        pandas.DataFrame
    """
    # Wrie your logic here
    # Assuming you have a dictionary mapping vehicle types to toll rates
    toll_rate_mapping = {
        'car': 0.05,  # Replace with actual toll rates
        'bus': 0.1,
        'truck': 0.2
        # Add more vehicle types as needed
    }

    # Merge the DataFrame with toll rates based on 'vehicle_type'
    df_with_toll_rate = df.merge(
        pd.DataFrame(list(toll_rate_mapping.items()), columns=['vehicle_type', 'toll_rate']),
        on='vehicle_type',
        how='left'
    )

    # Calculate toll fees based on distance and toll rate
    df_with_toll_rate['toll_fee'] = df_with_toll_rate['distance'] * df_with_toll_rate['toll_rate']

    return df_with_toll_rate

# Example usage:
# result_dataframe = calculate_toll_rate(your_unrolled_dataframe)

    return df

def calculate_time_based_toll_rates(df)->pd.DataFrame():
    """
    Calculate time-based toll rates for different time intervals within a day.

    Args:
        df (pandas.DataFrame)

    Returns:
        pandas.DataFrame
    """
    # Write your logic here
    # Define time intervals and corresponding toll rates
    time_intervals = [
        (0, 6),    # 12:00 AM to 6:00 AM
        (6, 12),   # 6:00 AM to 12:00 PM
        (12, 18),  # 12:00 PM to 6:00 PM
        (18, 24)   # 6:00 PM to 12:00 AM
    ]

    toll_rate_mapping = {
        'car': [0.04, 0.05, 0.06, 0.04],    # Replace with actual toll rates for each time interval
        'bus': [0.08, 0.1, 0.12, 0.08],
        'truck': [0.15, 0.2, 0.25, 0.15]
        # Add more vehicle types as needed
    }

    # Extract the hour from the timestamp
    df['hour'] = pd.to_datetime(df['timestamp']).dt.hour

    # Function to calculate time-based toll rates
    def calculate_rate(row):
        vehicle_type = row['vehicle_type']
        hour = row['hour']

        for interval, toll_rates in zip(time_intervals, toll_rate_mapping[vehicle_type]):
            start, end = interval
            if start <= hour < end:
                return toll_rates

    # Apply the function to create a new column for time-based toll rates
    df['time_based_toll_rate'] = df.apply(calculate_rate, axis=1)

    # Calculate toll fees based on distance and time-based toll rate
    df['time_based_toll_fee'] = df['distance'] * df['time_based_toll_rate']

    # Drop the temporary 'hour' column
    df = df.drop('hour', axis=1)

    return df

# Example usage:
# result_dataframe = calculate_time_based_toll_rates(your_dataframe)

    return df